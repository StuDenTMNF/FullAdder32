# FullAdder32
В данном репозитории будет рассказано о полном 32ух битном сумматоре на языке system verilog в среде разработки Quartus II PRO lite
### Теория
Предположим, что Вы хотите суммировать два числа. Конечно, вы умеете это делать. Поэтому Вы берете в самом простом случае 2 двух битных числа A и B. Давайте запишем для них таблицу истинности. 


S - это сумма. C - Это так называемый бит переноса, о котором будет сказано далее
Мы видим следующее - при двух единицах результат суммы переходит в следующий разряд. Поэтому мы переходим к процессу реализации неполного сумматора.
    
    
## Неполный сумматор(halfAdder)

Неполный сумматор - это такой элемент, который не учитывает бит переноса при получении двух чисел A и В. Т.е наша таблица теперь должна выглядеть следующим образом.


<img width="178" height="220" alt="image" src="https://github.com/user-attachments/assets/25ebc780-0e7e-4cc4-a8ca-6096c685d9f1" />
Запишем макстермы для S и С:

$$
S = \overline{A}B \lor \overline{B}A = A \oplus B
$$

$$
С = А \cdot B
$$

Исходя из формул мы получили мысль о том, что нас полусумматор - это волшебная коробочка со входами A и В. Эта коробочка имеет выходы S и С


<img width="599" height="259" alt="image" src="https://github.com/user-attachments/assets/4a1bf469-e4f6-4461-8b16-82ec1d2d499b" />


После приведения формул к простейшему виду для реализации мы можем описать аппаратуру на одном из языков. Я буду описывать на языке Systemverilog. 
В качестве упражнения и более глубоко понимания материала я советую отдельно реализовать модули XOR, AND и после этого использовать их в главном модуле, который будет называться, например, HalfAdder (или Top, кому как удобнее)

Приступаем к созданию полусумматора:
1. Создание And.
 ```
Systemverilog

//Наш модуль нельзя называть с точности And, т.к это конфликт с внутренней библиотекой Quartis

module Andd(
input  logic A, //объявляем тип переменной как logic
input  logic B,
output logic C
);

assign C = A & B;

endmodule
```
2. создание Xor
 ```
 Systemverilog

module Xorr(
input  logic A, B, 
output logic C
);

assign C = A | B;

endmodule 
```

3. Создание главного модуля HalfAdder
самое интересное в этой задаче начинается в данном пункте. Исходя из фото волшебной коробочки, которое мы получили из преобразования таблицы, мы записываем следующее:

```
Systemverilog

module HalfAdder(
input  logic a,
input  logic b,
output logic carry_o, sum_o
);
```
carry_o - это бит переноса 
sum_o - сумма
А вот для того, чтобы соединить модули Andd и Xorr в одном главном модуле HalfAdder, нужно:
*Объявить модуль, который Вы хотите соединить.
*Дать ему Имя, например And1
*Подключение элементов происходит таким образом: .A(a) . Мы явно показываем, что Вход Элемента Andd подсоединен ко входу a модуля HalfAdder.
В общем, выглядит это следующим образом:
```
Andd And1( .A(a), .B(b), .C(carry_o) );
```
Аналогично для sum_o запишите сами.

Анализируем и синтезируем. Открываем Netlist и в итоге:

<img width="1584" height="789" alt="image" src="https://github.com/user-attachments/assets/57d252cd-84c3-4076-b428-e7a6466145d6" />

Теперь можно переходить к полному сумматору.

## Полный сумматор.(FullAdder)

Неполный сумматор отличался тем, что в него не входил бит переноса Cin. Сейчас же нужно рассмотреть случай, при котором существует бит переноса Cin, входящий в наш сумматор.

Записываем таблицу истинности:
<img width="323" height="323" alt="image" src="https://github.com/user-attachments/assets/d73ce454-b736-4df4-8450-50055a40609e" />

Пишем макстермы для Cout, S.

$$ 
Cout = \overline{Сin}AB \lor Cin\overline{A}B \lor CinA\overline{B} \lor CinAB=AB \lor CoutA\overline{B} \lor Cout\overline{A}B = AB \lor CoutB \lor CoutA
$$

$$
S = \overline{Сin}\overline{A}B \lor \overline{Cin}A\overline{B} \lor Cin\overline{A}\overline{B} \lor CinAB = A \oplus B \oplus Cin 
$$

(нужно лишь сравнить таблицу истинности для трехвводового XOR'a и нашу таблицу истинности)

Для Cout же чуть чуть интереснее, но не менее просто. Мы всегда получаем единицу на выходах, когда хотя бы 2 элемента равны единице. Т.е к примеру, если Cout = 0, То мы получаем единицу на выходе только при AB = 0. Если же $Сout \neq 0$ , то мы получаем 1 на выходе при:
1. A=B=1
2. $A \neq B$. При A = 0, B=1, тогда $Сout\overline{A}B=1$ , аналогично для A = 1, B=0 и тогда $Cout\overline{B}A=1$ ,
Исходя из подобных рассуждений результат представлен в последнем равенстве.

Исходя из уравнений, который мы получили, нарисуем примерную схему нашего полного сумматора:

<img width="906" height="431" alt="image" src="https://github.com/user-attachments/assets/91eeeac2-5c38-4b0b-8643-cb7a6969aeb2" />






