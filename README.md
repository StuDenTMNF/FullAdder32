# FullAdder32
В данном репозитории будет рассказано о полном 32ух битном сумматоре на языке system verilog в среде разработки Quartus II PRO lite
### Теория
Предположим, что Вы хотите суммировать два числа. Конечно, вы умеете это делать. Поэтому Вы берете в самом простом случае 2 двух битных числа A и B. Давайте запишем для них таблицу истинности. 


S - это сумма. C - Это так называемый бит переноса, о котором будет сказано далее
Мы видим следующее - при двух единицах результат суммы переходит в следующий разряд. Поэтому мы переходим к процессу реализации неполного сумматора.
    
    
## Неполный сумматор(halfAdder)
Неполный сумматор - это такой элемент, который не учитывает бит переноса при получении двух чисел A и В. Т.е наша таблица теперь должна выглядеть следующим образом.


<img width="178" height="220" alt="image" src="https://github.com/user-attachments/assets/25ebc780-0e7e-4cc4-a8ca-6096c685d9f1" />
Запишем макстермы для S и С:

$$
S = \overline{A}B \lor \overline{B}A = A \oplus B
$$

$$
С = А \cdot B
$$

После приведения формул к простейшему виду для реализации мы можем описать аппаратуру на одном из языков. Я буду описывать на языке system verilog. 
В качестве упражнения и более глубоко понимания материала я советую отдельно реализовать модули XOR, AND и после этого использовать их в главном модуле, который будет называться, например, HalfAdder (или Top, кому как удобнее)

Приступаем к созданию полусумматора:
1. Создание And.
 ```
system verilog
//Наш модуль нельзя называть с точности And, т.к это конфликт с внутренней библиотекой Quartis
module Andd(
input  logic A, //объявляем тип переменной как logic
input  logic B,
output logic C
);

assign C = A & B;

endmodule
```
2. создание Xor
   
